<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui" />
    <title>Read article on thinking in react: @ reactjs.org</title>
    <link type="text/css" rel="stylesheet" href="assets/css/github-markdown.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/pilcrow.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/hljs-github.min.css" />
    <link type="text/css" rel="stylesheet" href="assets/css/mycss.css" />
    <script src="assets/myJs/copyToClipboardScript.js" defer></script>
  </head>
  <body>
    <article class="markdown-body"><h3 id="read-article-on-thinking-in-react:-@-reactjs.org"><a class="header-link" href="#read-article-on-thinking-in-react:-@-reactjs.org"></a>Read article on thinking in react: @ reactjs.org</h3>
<p><a href="https://reactjs.org/docs/thinking-in-react.html">link</a></p>
<hr>
<hr>
<h1 id="react.js:-5-awesome-packages-you-need-to-try-out"><a class="header-link" href="#react.js:-5-awesome-packages-you-need-to-try-out"></a>React.js: 5 awesome packages you need to try out</h1>
<p><a href="https://medium.com/javascript-in-plain-english/5-awesome-react-packages-you-need-to-try-out-20a156d3d73e">https://medium.com/javascript-in-plain-english/5-awesome-react-packages-you-need-to-try-out-20a156d3d73e</a></p>
<hr>
<h3 id="when-you-use-<>-and-</>-to-wrap-some-jsx-element-in-react,-when-parsed-in-html-it-gets-vanished,-you-won't-these-empty-braces-in-html-in-browser-or-the-code-that-is-produced-by-that-component."><a class="header-link" href="#when-you-use-<>-and-</>-to-wrap-some-jsx-element-in-react,-when-parsed-in-html-it-gets-vanished,-you-won't-these-empty-braces-in-html-in-browser-or-the-code-that-is-produced-by-that-component."></a>When you use &lt;&gt; and &lt;/&gt; to wrap some JSX element in react, when parsed in html it gets vanished, you won&#39;t these empty braces in html in browser or the code that is produced by that component.</h3>
<pre class="hljs"><code>      &lt;&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{props.text}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{props.filter}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span>
      &lt;<span class="hljs-regexp">/&gt;
</span></code></pre><hr>
<h2 id="another-importantreact-patterns-:-https://dev.to/codeartistryio/the-react-cheatsheet-for-2020-real-world-examples-4hgg-<<-this-one-looks-damm-pretty."><a class="header-link" href="#another-importantreact-patterns-:-https://dev.to/codeartistryio/the-react-cheatsheet-for-2020-real-world-examples-4hgg-<<-this-one-looks-damm-pretty."></a>Another importantreact patterns : <a href="https://dev.to/codeartistryio/the-react-cheatsheet-for-2020-real-world-examples-4hgg">https://dev.to/codeartistryio/the-react-cheatsheet-for-2020-real-world-examples-4hgg</a> &lt;&lt; this one looks damm pretty.</h2>
<p>Another article on read states: <a href="https://medium.com/hackernoon/a-different-way-to-manage-state-in-react-2d21dfb94482">Link</a></p>
<h2 id="another-important-react-patterns-:--https://vasanthk.gitbooks.io/react-bits/"><a class="header-link" href="#another-important-react-patterns-:--https://vasanthk.gitbooks.io/react-bits/"></a>Another important react patterns :- <a href="https://vasanthk.gitbooks.io/react-bits/">https://vasanthk.gitbooks.io/react-bits/</a></h2>
<hr>
<h1 id="below-content-is-served-from-https://reactpatterns.com/"><a class="header-link" href="#below-content-is-served-from-https://reactpatterns.com/"></a>Below content is served from <a href="https://reactpatterns.com/">https://reactpatterns.com/</a></h1>
<hr>
<h2 id="element"><a class="header-link" href="#element"></a>Element</h2>
<p><a href="https://reactjs.org/docs/glossary.html#elements">Elements</a> are anything inside angle brackets.</p>
<pre class="hljs"><code>&lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;Greeting /&gt;</code></pre><p><a href="https://reactpatterns.com/#component">Components</a> return Elements.</p>
<hr>
<h2 id="component"><a class="header-link" href="#component"></a>Component</h2>
<p>Define a <a href="https://reactjs.org/docs/glossary.html#components">Component</a> by declaring a function that returns a React <a href="https://reactpatterns.com/#element">Element</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi there!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><hr>
<h2 id="expressions"><a class="header-link" href="#expressions"></a>Expressions</h2>
<p>Use curly braces to <a href="https://reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx">embed expressions</a> in <a href="https://reactjs.org/docs/glossary.html#jsx">JSX</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> name = <span class="hljs-string">"chantastic"</span>;

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><hr>
<h2 id="props"><a class="header-link" href="#props"></a>Props</h2>
<p>Take <code>props</code> as an argument to allow outside customizations of your Component.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><hr>
<h2 id="defaultprops"><a class="header-link" href="#defaultprops"></a>defaultProps</h2>
<p>Specify default values for <code>props</code> with <code>defaultProps</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
Greeting.defaultProps = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Guest"</span>
};</code></pre><hr>
<h2 id="jsx-spread-attributes"><a class="header-link" href="#jsx-spread-attributes"></a>JSX spread attributes</h2>
<p>Spread Attributes is a feature of <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a>.
It&#39;s a syntax for providing an object&#39;s properties as JSX attributes.</p>
<p>Following the example from <a href="https://reactpatterns.com/#destructuring-props">Destructuring props</a>,
We can <strong>spread</strong> <code>restProps</code> over our <code></code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">{ name, ...restProps }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...restProps</span>}&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}</code></pre><hr>
<h2 id="merge-destructured-props-with-other-values"><a class="header-link" href="#merge-destructured-props-with-other-values"></a>Merge destructured props with other values</h2>
<p>Components are abstractions.
Good abstractions allow for extension.</p>
<p>Consider this component that uses a <code>class</code> attribute for style a <code>button</code>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"btn"</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><p>This works great until we try to extend it with another class.</p>
<pre class="hljs"><code>&lt;MyButton className=<span class="hljs-string">"delete-btn"</span>&gt;Delete...&lt;<span class="hljs-regexp">/MyButton&gt;</span></code></pre><p>In this case, <code>delete-btn</code> replaces <code>btn</code>.</p>
<p>Order matters for <a href="https://reactpatterns.com/#jsx-spread-attributes">JSX spread attributes</a>.
The <code>props.className</code> being spread is overriding the <code>className</code> in our component.</p>
<hr>
<p>We need to use destructuring assignment to get the incoming <code>className</code> and merge with the base <code>className</code>.
We can do this simply by adding all values to an array and joining them with a space.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">{ className, ...props }</span>) </span>{
  <span class="hljs-keyword">let</span> classNames = [<span class="hljs-string">"btn"</span>, className].join(<span class="hljs-string">" "</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{classNames}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><p>To guard from <code>undefined</code> showing up as a className,
Use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values_2">default values</a>.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyButton</span>(<span class="hljs-params">{ className = <span class="hljs-string">""</span>, ...props }</span>) </span>{
  <span class="hljs-keyword">let</span> classNames = [<span class="hljs-string">"btn"</span>, className].join(<span class="hljs-string">" "</span>);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{classNames}</span> {<span class="hljs-attr">...props</span>} /&gt;</span>;
}</span></code></pre><hr>
<h2 id="conditional-rendering"><a class="header-link" href="#conditional-rendering"></a>Conditional rendering</h2>
<p>You can&#39;t use if/else statements inside a component declarations.
So <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">conditional (ternary) operator</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation">short-circuit evaluation</a> are your friends.</p>
<h3 id="`if`"><a class="header-link" href="#`if`"></a><code>if</code></h3>
<pre class="hljs"><code>{
  condition &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `truthy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;
}</code></pre><h3 id="`unless`"><a class="header-link" href="#`unless`"></a><code>unless</code></h3>
<pre class="hljs"><code>{
  condition || <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `falsy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>;
}</code></pre><h3 id="`if-else`"><a class="header-link" href="#`if-else`"></a><code>if-else</code></h3>
<pre class="hljs"><code>{
  condition ? (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `truthy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  ) : (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Rendered when `falsy`<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
  );
}</code></pre><hr>
<hr>
<hr>
<h1 id="**unread**"><a class="header-link" href="#**unread**"></a><strong>unread</strong></h1>
<h2 id="children-types"><a class="header-link" href="#children-types"></a>Children types</h2>
<p>React can render <code>children</code> from most types.
In most cases it&#39;s either an <code>array</code> or a <code>string</code>.</p>
<h3 id="`string`"><a class="header-link" href="#`string`"></a><code>String</code></h3>
<pre class="hljs"><code>&lt;div&gt;Hello World!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><h3 id="`array`"><a class="header-link" href="#`array`"></a><code>Array</code></h3>
<pre class="hljs"><code>&lt;div&gt;{[<span class="hljs-string">"Hello "</span>, &lt;span&gt;World&lt;<span class="hljs-regexp">/span&gt;, "!"]}&lt;/</span>div&gt;</code></pre><h2 id="array-as-children"><a class="header-link" href="#array-as-children"></a>Array as children</h2>
<p>Providing an array as <code>children</code> is a very common.
It&#39;s how lists are drawn in React.</p>
<p>We use <code>map()</code> to create an array of React Elements for every value in the array.</p>
<pre class="hljs"><code>&lt;ul&gt;
  {[<span class="hljs-string">"first"</span>, <span class="hljs-string">"second"</span>].map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  ))}
&lt;<span class="hljs-regexp">/ul&gt;</span></code></pre><p>That&#39;s equivalent to providing a literal <code>array</code>.</p>
<pre class="hljs"><code>&lt;ul&gt;{[<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>first<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>, &lt;li&gt;second&lt;<span class="hljs-regexp">/li&gt;]}&lt;/u</span>l&gt;</code></pre><p>This pattern can be combined with destructuring, JSX Spread Attributes, and other components, for some serious terseness.</p>
<pre class="hljs"><code>&lt;ul&gt;
  {arrayOfMessageObjects.map(<span class="hljs-function">(<span class="hljs-params">{ id, ...message }</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Message</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{id}</span> {<span class="hljs-attr">...message</span>} /&gt;</span>
  ))}
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></code></pre><h2 id="function-as-children"><a class="header-link" href="#function-as-children"></a>Function as children</h2>
<p>React components don&#39;t support functions as <code>children</code>. However, <a href="https://reactpatterns.com/#render-prop">render props</a> is a pattern for creating components that take functions as children.</p>
<h2 id="render-prop"><a class="header-link" href="#render-prop"></a>Render prop</h2>
<p>Here&#39;s a component that uses a render callback.
It&#39;s not useful, but it&#39;s an easy illustration to start with.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Width = <span class="hljs-function">(<span class="hljs-params">{ children }</span>) =&gt;</span> children(<span class="hljs-number">500</span>);</code></pre><p>The component calls <code>children</code> as a function, with some number of arguments. Here, it&#39;s the number <code>500</code>.</p>
<p>To use this component, we give it a <a href="https://reactpatterns.com/#function-as-children">function as <code>children</code></a>.</p>
<pre class="hljs"><code>&lt;Width&gt;{width =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>window is {width}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>}&lt;<span class="hljs-regexp">/Width&gt;</span></code></pre><p>We get this output.</p>
<pre class="hljs"><code>&lt;div&gt;<span class="hljs-built_in">window</span> is <span class="hljs-number">500</span>&lt;<span class="hljs-regexp">/div&gt;</span></code></pre><p>With this setup, we can use this <code>width</code> to make rendering decisions.</p>
<pre class="hljs"><code>&lt;Width&gt;
  {width =&gt; (width &gt; <span class="hljs-number">600</span> ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>min-width requirement met!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> : <span class="hljs-literal">null</span>)}
&lt;<span class="hljs-regexp">/Width&gt;</span></code></pre><p>If we plan to use this condition a lot, we can define another components to encapsulate the reused logic.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> MinWidth = <span class="hljs-function">(<span class="hljs-params">{ width: minWidth, children }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Width</span>&gt;</span>{width =&gt; (width &gt; minWidth ? children : null)}<span class="hljs-tag">&lt;/<span class="hljs-name">Width</span>&gt;</span></span>
);</code></pre><p>Obviously a static <code>Width</code> component isn&#39;t useful but one that watches the browser window is. Here&#39;s a sample implementation.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowWidth</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">width</span>: <span class="hljs-number">0</span> };
  }

  componentDidMount() {
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">width</span>: <span class="hljs-built_in">window</span>.innerWidth }, () =&gt;
      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>, ({ target }) =&gt;
        <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">width</span>: target.innerWidth })
      )
    );
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.children(<span class="hljs-keyword">this</span>.state.width);
  }
}</code></pre><p>Many developers favor <a href="https://reactpatterns.com/#higher-order-component">Higher Order Components</a> for this type of functionality. It&#39;s a matter of preference.</p>
<h2 id="children-pass-through"><a class="header-link" href="#children-pass-through"></a>Children pass-through</h2>
<p>You might create a component designed to apply <code>context</code> and render its <code>children</code>.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeContextProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  getChildContext() {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">some</span>: <span class="hljs-string">"context"</span> };
  }

  render() {
    <span class="hljs-comment">// how best do we return `children`?</span>
  }
}</code></pre><p>You&#39;re faced with a decision. Wrap <code>children</code> in an extraneous <code></code> or return <code>children</code> directly. The first options gives you extra markup (which can break some stylesheets). The second will result in unhelpful errors.</p>
<pre class="hljs"><code><span class="hljs-comment">// option 1: extra div</span>
<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{children}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// option 2: unhelpful errors</span>
<span class="hljs-keyword">return</span> children;</code></pre><p>It&#39;s best to treat <code>children</code> as an opaque data type. React provides <code>React.Children</code> for dealing with <code>children</code> appropriately.</p>
<pre class="hljs"><code><span class="hljs-keyword">return</span> React.Children.only(<span class="hljs-keyword">this</span>.props.children);</code></pre><h2 id="proxy-component"><a class="header-link" href="#proxy-component"></a>Proxy component</h2>
<p><em>(I&#39;m not sure if this name makes sense)</em></p>
<p>Buttons are everywhere in web apps. And every one of them must have the <code>type</code> attribute set to &quot;button&quot;.</p>
<pre class="hljs"><code>&lt;button type=<span class="hljs-string">"button"</span>&gt;</code></pre><p>Writing this attribute hundreds of times is error prone. We can write a higher level component to proxy <code>props</code> to a lower-level <code>button</code> component.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Button = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>
  &lt;button type=<span class="hljs-string">"button"</span> {...props}&gt;</code></pre><p>We can use <code>Button</code> in place of <code>button</code> and ensure that the <code>type</code> attribute is consistently applied everywhere.</p>
<pre class="hljs"><code>&lt;Button /&gt;
<span class="hljs-comment">// &lt;button type="button"&gt;&lt;button&gt;</span>

&lt;Button className=<span class="hljs-string">"CTA"</span>&gt;Send Money&lt;<span class="hljs-regexp">/Button&gt;
/</span><span class="hljs-regexp">/ &lt;button type="button" class="CTA"&gt;Send Money&lt;/</span>button&gt;</code></pre><h2 id="style-component"><a class="header-link" href="#style-component"></a>Style component</h2>
<p>This is a <a href="https://reactpatterns.com/#proxy-component">Proxy component</a> applied to the practices of style.</p>
<p>Say we have a button. It uses classes to be styled as a &quot;primary&quot; button.</p>
<pre class="hljs"><code>&lt;button type=<span class="hljs-string">"button"</span> className=<span class="hljs-string">"btn btn-primary"</span>&gt;</code></pre><p>We can generate this output using a couple single-purpose components.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> classnames <span class="hljs-keyword">from</span> <span class="hljs-string">"classnames"</span>;

<span class="hljs-keyword">const</span> PrimaryBtn = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &lt;Btn {...props} primary /&gt;;

<span class="hljs-keyword">const</span> Btn = <span class="hljs-function">(<span class="hljs-params">{ className, primary, ...props }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">className</span>=<span class="hljs-string">{classnames(</span>"<span class="hljs-attr">btn</span>", <span class="hljs-attr">primary</span> &amp;&amp; "<span class="hljs-attr">btn-primary</span>", <span class="hljs-attr">className</span>)}
    {<span class="hljs-attr">...props</span>}
  /&gt;</span>
);</span></code></pre><p>It can help to visualize this.</p>
<pre class="hljs"><code>PrimaryBtn()
  ↳ Btn({<span class="hljs-attr">primary</span>: <span class="hljs-literal">true</span>})
    ↳ Button({<span class="hljs-attr">className</span>: <span class="hljs-string">"btn btn-primary"</span>}, <span class="hljs-attr">type</span>: <span class="hljs-string">"button"</span>})
      ↳ <span class="hljs-string">'&lt;button type="button" class="btn btn-primary"&gt;&lt;/button&gt;'</span></code></pre><p>Using these components, all of these result in the same output.</p>
<pre class="hljs"><code>&lt;PrimaryBtn /&gt;
&lt;Btn primary /&gt;
&lt;button type="button" className="btn btn-primary" /&gt;</code></pre><p>This can be a huge boon to style maintenance. It isolates all concerns of style to a single component.</p>
<h2 id="event-switch"><a class="header-link" href="#event-switch"></a>Event switch</h2>
<p>When writing event handlers it&#39;s common to adopt the <code>handle{eventName}</code> naming convention.</p>
<pre class="hljs"><code>handleClick(e) { <span class="hljs-comment">/* do something */</span> }</code></pre><p>For components that handle several event types, these function names can be repetitive. The names themselves might not provide much value, as they simply proxy to other actions/functions.</p>
<pre class="hljs"><code>handleClick() { <span class="hljs-built_in">require</span>(<span class="hljs-string">"./actions/doStuff"</span>)(<span class="hljs-comment">/* action stuff */</span>) }
handleMouseEnter() { <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">true</span> }) }
handleMouseLeave() { <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">false</span> }) }</code></pre><p>Consider writing a single event handler for your component and switching on <code>event.type</code>.</p>
<pre class="hljs"><code>handleEvent({type}) {
  <span class="hljs-keyword">switch</span>(type) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"click"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">"./actions/doStuff"</span>)(<span class="hljs-comment">/* action dates */</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-string">"mouseenter"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">true</span> })
    <span class="hljs-keyword">case</span> <span class="hljs-string">"mouseleave"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">hovered</span>: <span class="hljs-literal">false</span> })
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">`No case for event type "<span class="hljs-subst">${type}</span>"`</span>)
  }
}</code></pre><p>Alternatively, for simple components, you can call imported actions/functions directly from components, using arrow functions.</p>
<pre class="hljs"><code>&lt;div onClick={() =&gt; someImportedAction({ <span class="hljs-attr">action</span>: <span class="hljs-string">"DO_STUFF"</span> })}</code></pre><p>Don&#39;t fret about performance optimizations until you have problems. Seriously don&#39;t.</p>
<h2 id="layout-component"><a class="header-link" href="#layout-component"></a>Layout component</h2>
<p>Layout components result in some form of static DOM element. It might not need to update frequently, if ever.</p>
<p>Consider a component that renders two <code>children</code> side-by-side.</p>
<pre class="hljs"><code>&lt;HorizontalSplit
  startSide={&lt;SomeSmartComponent /&gt;}
  endSide={&lt;AnotherSmartComponent /&gt;}
/&gt;</code></pre><p>We can aggressively optimize this component.</p>
<p>While <code>HorizontalSplit</code> will be <code>parent</code> to both components, it will never be their <code>owner</code>. We can tell it to update never, without interrupting the lifecycle of the components inside.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HorizontalSplit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  shouldComponentUpdate() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FlexContainer</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.startSide}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.endSide}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">FlexContainer</span>&gt;</span></span>
    );
  }
}</code></pre><h2 id="container-component"><a class="header-link" href="#container-component"></a>Container component</h2>
<p>&quot;A container does data fetching and then renders its corresponding sub-component. That’s it.&quot;—<a href="https://twitter.com/jasonbonta">Jason Bonta</a></p>
<p>Given this reusable <code>CommentList</code> component.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> CommentList = <span class="hljs-function">(<span class="hljs-params">{ comments }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    {comments.map(comment =&gt; (
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
        {comment.body}-{comment.author}
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    ))}
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
);</code></pre><p>We can create a new component responsible for fetching data and rendering the <code>CommentList</code> function component.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">comments</span>: [] }
  }

  componentDidMount() {
    $.ajax({
      <span class="hljs-attr">url</span>: <span class="hljs-string">"/my-comments.json"</span>,
      <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>,
      <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">comments</span> =&gt;</span>
        <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">comments</span>: comments});
    })
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CommentList</span> <span class="hljs-attr">comments</span>=<span class="hljs-string">{this.state.comments}</span> /&gt;</span>
  }
}</span></code></pre><p>We can write different containers for different application contexts.</p>
<h2 id="higher-order-component"><a class="header-link" href="#higher-order-component"></a>Higher-order component</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order function</a> is a function that takes and/or returns a function. It&#39;s not more complicated than that. So, what&#39;s a higher-order component?</p>
<p>If you&#39;re already using <a href="https://reactpatterns.com/#container-component">container components</a>, these are just generic containers, wrapped up in a function.</p>
<p>Let&#39;s start with our <code>Greeting</code> component.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Greeting = <span class="hljs-function">(<span class="hljs-params">{ name }</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Connecting...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};</code></pre><p>If it gets <code>props.name</code>, it&#39;s gonna render that data. Otherwise it&#39;ll say that it&#39;s &quot;Connecting...&quot;. Now for the the higher-order bit.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Connect = <span class="hljs-function"><span class="hljs-params">ComposedComponent</span> =&gt;</span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">super</span>();
      <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">""</span> };
    }

    componentDidMount() {
      <span class="hljs-comment">// this would fetch or connect to a store</span>
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">name</span>: <span class="hljs-string">"Michael"</span> });
    }

    render() {
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ComposedComponent</span> {<span class="hljs-attr">...this.props</span>} <span class="hljs-attr">name</span>=<span class="hljs-string">{this.state.name}</span> /&gt;</span>;
    }
  };</span></code></pre><p>This is just a function that returns component that renders the component we passed as an argument.</p>
<p>Last step, we need to wrap our <code>Greeting</code> component in <code>Connect</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> ConnectedMyComponent = Connect(Greeting);</code></pre><p>This is a powerful pattern for providing fetching and providing data to any number of <a href="https://reactpatterns.com/#function-component">function components</a>.</p>
<h2 id="state-hoisting"><a class="header-link" href="#state-hoisting"></a>State hoisting</h2>
<p><a href="https://reactpatterns.com/#function-component">function-component</a> don&#39;t hold state (as the name implies).</p>
<p>Events are changes in state. Their data needs to be passed to stateful <a href="https://reactpatterns.com/#container-component">container components</a> parents.</p>
<p>This is called &quot;state hoisting&quot;. It&#39;s accomplished by passing a callback from a container component to a child component.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;Name onChange={newName =&gt; alert(newName)} /&gt;;
  }
}

const Name = ({ onChange }) =&gt; (
  &lt;input onChange={e =&gt; onChange(e.target.value)} /&gt;
);</code></pre><p><code>Name</code> receives an <code>onChange</code> callback from <code>NameContainer</code> and calls on events.</p>
<p>The <code>alert</code> above makes for a terse demo but it&#39;s not changing state. Let&#39;s change the internal state of <code>NameContainer</code>.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">""</span> };
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Name</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{newName</span> =&gt;</span> this.setState({ name: newName })} /&gt;;
  }
}</span></code></pre><p>The state is <em>hoisted</em> to the container, by the provided callback, where it&#39;s used to update local state. This sets a nice clear boundary and maximizes the re-usability of function component.</p>
<p>This pattern isn&#39;t limited to function components. Because function components don&#39;t have lifecycle events, you&#39;ll use this pattern with component classes as well.</p>
<p><em><a href="https://reactpatterns.com/#controlled-input">Controlled input</a> is an important pattern to know for use with state hoisting</em></p>
<p><em>(It&#39;s best to process the event object on the stateful component)</em></p>
<h2 id="controlled-input"><a class="header-link" href="#controlled-input"></a>Controlled input</h2>
<p>It&#39;s hard to talk about controlled inputs in the abstract. Let&#39;s start with an uncontrolled (normal) input and go from there.</p>
<pre class="hljs"><code>&lt;input type=<span class="hljs-string">"text"</span> /&gt;</code></pre><p>When you fiddle with this input in the browser, you see your changes. This is normal.</p>
<p>A controlled input disallows the DOM mutations that make this possible. You set the <code>value</code> of the input in component-land and it doesn&#39;t change in DOM-land.</p>
<pre class="hljs"><code>&lt;input type=<span class="hljs-string">"text"</span> value=<span class="hljs-string">"This won't change. Try it."</span> /&gt;</code></pre><p>Obviously static inputs aren&#39;t very useful to your users. So, we derive a <code>value</code> from state.</p>
<pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControlledNameInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">name</span>: <span class="hljs-string">""</span> };
  }

  render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.name}</span> /&gt;</span>;
  }
}</span></code></pre><p>Then, changing the input is a matter of changing component state.</p>
<pre class="hljs"><code><span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.name}</span>
    <span class="hljs-attr">onChange</span>=<span class="hljs-string">{e</span> =&gt;</span> this.setState({ name: e.target.value })}
  /&gt;
);</span></code></pre><p>This is a controlled input. It only updates the DOM when state has changed in our component. This is invaluable when creating consistent UIs.</p>
<p><em>If you&#39;re using <a href="https://reactpatterns.com/#function-component">function components</a> for form elements, read about using <a href="https://reactpatterns.com/#state-hoisting">state hoisting</a> to move new state up the component tree.</em></p>
</article>
  </body>
</html>
